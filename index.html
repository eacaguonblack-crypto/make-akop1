<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Art Filter - Mr. Parker</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a0515; /* Deep purple base */
        }

        /* The main canvas where we draw the art */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror the webcam like a real mirror */
        }

        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF00FF;
            font-family: monospace;
            font-size: 1.5rem;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 2px solid #FF00FF;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing Camera & AI...</div>
    
    <video id="input_video" style="display: none"></video>
    
    <canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d');
    const loading = document.getElementById('loading');

    // ==========================================
    // 1. LIQUID BACKGROUND LOGIC (From previous step)
    // ==========================================
    let width, height;
    
    const config = {
        blobCount: 8,
        colors: ['#FF00FF', '#FF69B4', '#C71585', '#FF1493', '#9400D3'],
        speed: 0.003
    };

    let blobs = [];

    class Blob {
        constructor() { this.init(); }
        init() {
            // Spawn mostly near edges to frame the user
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { this.x = Math.random() * width; this.y = -50; }
            else if (edge === 1) { this.x = Math.random() * width; this.y = height + 50; }
            else if (edge === 2) { this.x = -50; this.y = Math.random() * height; }
            else { this.x = width + 50; this.y = Math.random() * height; }

            this.radius = Math.random() * (width * 0.1) + 50;
            this.color = config.colors[Math.floor(Math.random() * config.colors.length)];
            this.vx = (Math.random() - 0.5) * 1;
            this.vy = (Math.random() - 0.5) * 1;
            
            this.points = [];
            this.numPoints = 8;
            for (let i = 0; i < this.numPoints; i++) {
                this.points.push({
                    angle: (Math.PI * 2) / this.numPoints * i,
                    speed: Math.random() * 0.05 + 0.01,
                    offset: Math.random() * Math.PI * 2,
                    volatility: Math.random() * 20 + 10
                });
            }
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            if (this.x < -200 || this.x > width + 200) this.vx *= -1;
            if (this.y < -200 || this.y > height + 200) this.vy *= -1;
        }
        draw(ctx, time) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            let firstP = this.getPoint(0, time);
            ctx.moveTo(firstP.x, firstP.y);
            for (let i = 0; i <= this.numPoints; i++) {
                let p1 = this.getPoint(i % this.numPoints, time);
                let p2 = this.getPoint((i + 1) % this.numPoints, time);
                ctx.quadraticCurveTo(p1.x, p1.y, (p1.x + p2.x)/2, (p1.y + p2.y)/2);
            }
            ctx.fill();
        }
        getPoint(i, time) {
            let p = this.points[i];
            let r = this.radius + Math.sin(time * p.speed + p.offset) * p.volatility;
            return { x: this.x + Math.cos(p.angle) * r, y: this.y + Math.sin(p.angle) * r };
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvasElement.width = width;
        canvasElement.height = height;
        blobs = [];
        for(let i=0; i<config.blobCount; i++) blobs.push(new Blob());
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // 2. MEDIAPIPE SEGMENTATION LOGIC
    // ==========================================
    
    function onResults(results) {
        loading.style.display = 'none';

        // A. Draw the Liquid Background First
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#1a0515'; // Dark purple background
        ctx.fillRect(0, 0, width, height);

        const time = Date.now();
        blobs.forEach(blob => {
            blob.update();
            blob.draw(ctx, time * config.speed);
        });

        // B. Prepare the User Mask (The Cutout)
        // We use the segmentation mask provided by MediaPipe
        ctx.globalCompositeOperation = 'destination-out'; 
        ctx.beginPath();
        // Draw the segmentation mask onto the canvas to "punch a hole" in the liquid BG?
        // Actually, we want to draw the user ON TOP.
        
        // Let's switch strategies:
        // 1. Draw Liquid BG (Done above)
        // 2. Draw the User, but ONLY where the mask says they are.
        
        ctx.globalCompositeOperation = 'source-over';

        // We create a temporary canvas to process the user video style
        // This is where we apply the "Magenta/Pink Filter" to you
        // For performance in a single file, we will use composite blending.
        
        // Draw the mask (The white silhouette of the user)
        ctx.save();
        ctx.drawImage(results.segmentationMask, 0, 0, width, height);
        
        // Only keep the pixels that overlap with the mask (The User)
        ctx.globalCompositeOperation = 'source-in';
        
        // Draw the webcam video into the masked area
        ctx.drawImage(results.image, 0, 0, width, height);
        
        // C. Apply "Art Style" to the User
        // We want to make the user look like pink/purple vector art.
        
        // 1. Apply a purple tint to dark areas
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = '#ff00ff'; 
        ctx.fillRect(0, 0, width, height);

        // 2. Add brightness/contrast to pop
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.5;
        ctx.drawImage(results.image, 0, 0, width, height); // Layer video again for highlights
        ctx.globalAlpha = 1.0;
        
        // 3. Optional
