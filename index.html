<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Filter - Fixed</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a0515; /* Dark Purple */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror effect */
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FF00FF;
            font-family: monospace;
            font-weight: bold;
            z-index: 100;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        video { display: none; }
    </style>
</head>
<body>

    <div id="status">Initializing System...</div>
    <video id="input_video" playsinline muted></video>
    <canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d');
    const statusDiv = document.getElementById('status');

    let width, height;
    let segmentationResults = null;
    
    // --- 1. SETUP LIQUID BLOBS ---
    const config = {
        blobCount: 8,
        colors: ['#FF00FF', '#FF69B4', '#C71585', '#FF1493', '#9400D3'],
        speed: 0.002
    };

    let blobs = [];

    class Blob {
        constructor() { this.init(); }
        init() {
            // Frame the edges
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { this.x = Math.random() * width; this.y = -50; }
            else if (edge === 1) { this.x = Math.random() * width; this.y = height + 50; }
            else if (edge === 2) { this.x = -50; this.y = Math.random() * height; }
            else { this.x = width + 50; this.y = Math.random() * height; }

            this.radius = Math.random() * (width * 0.15) + 50;
            this.color = config.colors[Math.floor(Math.random() * config.colors.length)];
            this.vx = (Math.random() - 0.5) * 1.5;
            this.vy = (Math.random() - 0.5) * 1.5;
            
            this.points = [];
            this.numPoints = 8;
            for (let i = 0; i < this.numPoints; i++) {
                this.points.push({
                    angle: (Math.PI * 2) / this.numPoints * i,
                    speed: Math.random() * 0.05 + 0.01,
                    offset: Math.random() * Math.PI * 2,
                    volatility: Math.random() * 20 + 10
                });
            }
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            if (this.x < -200 || this.x > width + 200) this.vx *= -1;
            if (this.y < -200 || this.y > height + 200) this.vy *= -1;
        }
        draw(ctx, time) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            let firstP = this.getPoint(0, time);
            ctx.moveTo(firstP.x, firstP.y);
            for (let i = 0; i <= this.numPoints; i++) {
                let p1 = this.getPoint(i % this.numPoints, time);
                let p2 = this.getPoint((i + 1) % this.numPoints, time);
                ctx.quadraticCurveTo(p1.x, p1.y, (p1.x + p2.x)/2, (p1.y + p2.y)/2);
            }
            ctx.fill();
        }
        getPoint(i, time) {
            let p = this.points[i];
            let r = this.radius + Math.sin(time * p.speed + p.offset) * p.volatility;
            return { x: this.x + Math.cos(p.angle) * r, y: this.y + Math.sin(p.angle) * r };
        }
    }

    // --- 2. RESIZE HANDLER ---
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvasElement.width = width;
        canvasElement.height = height;
        offscreenCanvas.width = width;
        offscreenCanvas.height = height;
        blobs = [];
        for(let i=0; i<config.blobCount; i++) blobs.push(new Blob());
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 3. MAIN RENDER LOOP ---
    function loop() {
        const time = Date.now();

        // A. ALWAYS Draw Background (Fixes Black Screen)
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#1a0515';
        ctx.fillRect(0, 0, width, height);

        blobs.forEach(blob => {
            blob.update();
            blob.draw(ctx, time * config.speed);
        });

        // B. Check Camera Status
        if (videoElement.readyState >= 2) {
            ctx.save();
            
            // If AI is ready, perform cutout logic
            if (segmentationResults) {
                statusDiv.innerText = "AI ACTIVE (Background Removed)";
                
                // 1. Draw Mask to Offscreen
                offscreenCtx.clearRect(0,0,width,height);
                offscreenCtx.drawImage(segmentationResults.segmentationMask, 0, 0, width, height);
                
                // 2. Composite User into Mask
                offscreenCtx.globalCompositeOperation = 'source-in';
                offscreenCtx.drawImage(segmentationResults.image, 0, 0, width, height);

                // 3. Draw Cutout User to Main Canvas
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(offscreenCanvas, 0, 0);

            } else {
                // Fallback: Just draw the camera video full screen (Ghost Mode)
                statusDiv.innerText = "CAMERA ACTIVE (Loading AI...)";
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(videoElement, 0, 0, width, height);
            }

            // C. Apply Magenta/Purple Filter to the user layer
            // This tints whatever video is visible (cutout or full)
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.4;
            // Draw video again for highlights
            if(segmentationResults) {
                ctx.drawImage(offscreenCanvas, 0, 0); 
            } else {
                ctx.drawImage(videoElement, 0, 0);
            }
            ctx.globalAlpha = 1.0;
            ctx.restore();
        
        } else {
            statusDiv.innerText = "WAITING FOR CAMERA...";
        }

        requestAnimationFrame(loop);
    }
    // Start Loop Immediately
    loop();

    // --- 4. HARDWARE STARTUP ---
    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720, facingMode: "user" },
                audio: false
            });
            videoElement.srcObject = stream;
            // Crucial: Force play
            await videoElement.play(); 
        } catch (err) {
            console.error(err);
            statusDiv.innerText = "ERROR: Camera Access Denied";
            alert("Please allow camera access to use this filter.");
        }
    }
    startCamera();

    // --- 5. AI LOADING ---
    const selfieSegmentation = new SelfieSegmentation({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
    }});

    selfieSegmentation.setOptions({
        modelSelection: 1,
        selfieMode: true
    });

    selfieSegmentation.onResults(results => {
        segmentationResults = results;
    });

    // Send video to AI loop
    async function sendToAI() {
        if (videoElement.readyState >= 2) {
            await selfieSegmentation.send({image: videoElement});
        }
        requestAnimationFrame(sendToAI);
    }
    sendToAI();

</script>
</body>
</html>
