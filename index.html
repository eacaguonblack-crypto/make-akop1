<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Liquid - Mr. Parker</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a0515;
            font-family: sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror Mode */
        }

        /* Start Button to unlock audio/video context */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0515;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }
        
        button {
            padding: 20px 50px;
            font-size: 2rem;
            background: #FF00FF;
            color: #1a0515;
            border: none;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 20px #FF00FF;
        }

        video { display: none; }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="start-btn">ACTIVATE LIQUID MODE</button>
    </div>

    <video id="input_video" playsinline muted></video>
    <canvas id="output_canvas"></canvas>

<script>
    const startBtn = document.getElementById('start-btn');
    const overlay = document.getElementById('overlay');
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d', { willReadFrequently: true });

    let width, height;
    let segmentationResults = null;
    let lastTime = 0;

    // --- 1. BACKGROUND BLOBS ---
    const config = {
        blobCount: 6,
        colors: ['#FF00FF', '#9400D3', '#C71585'], // Magenta, Violet, Deep Pink
        speed: 0.002
    };

    let blobs = [];

    class Blob {
        constructor() { this.init(); }
        init() {
            // Spawn anywhere
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.radius = Math.random() * (width * 0.2) + 50;
            this.color = config.colors[Math.floor(Math.random() * config.colors.length)];
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            
            this.points = [];
            this.numPoints = 7;
            for (let i = 0; i < this.numPoints; i++) {
                this.points.push({
                    angle: (Math.PI * 2) / this.numPoints * i,
                    speed: Math.random() * 0.04 + 0.01,
                    offset: Math.random() * Math.PI * 2,
                    volatility: Math.random() * 30 + 10
                });
            }
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            if (this.x < -200 || this.x > width + 200) this.vx *= -1;
            if (this.y < -200 || this.y > height + 200) this.vy *= -1;
        }
        draw(ctx, time) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            let firstP = this.getPoint(0, time);
            ctx.moveTo(firstP.x, firstP.y);
            for (let i = 0; i <= this.numPoints; i++) {
                let p1 = this.getPoint(i % this.numPoints, time);
                let p2 = this.getPoint((i + 1) % this.numPoints, time);
                ctx.quadraticCurveTo(p1.x, p1.y, (p1.x + p2.x)/2, (p1.y + p2.y)/2);
            }
            ctx.fill();
        }
        getPoint(i, time) {
            let p = this.points[i];
            let r = this.radius + Math.sin(time * p.speed + p.offset) * p.volatility;
            return { x: this.x + Math.cos(p.angle) * r, y: this.y + Math.sin(p.angle) * r };
        }
    }

    // --- 2. VECTOR PROCESSING HELPER ---
    // We need a temp canvas to analyze pixel brightness
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvasElement.width = width;
        canvasElement.height = height;
        // Use a smaller canvas for pixel processing to keep it fast (downsampling)
        tempCanvas.width = 320; 
        tempCanvas.height = 180;
        
        blobs = [];
        for(let i=0; i<config.blobCount; i++) blobs.push(new Blob());
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 3. MAIN LOOP ---
    function loop() {
        const time = Date.now();

        // A. Draw Background Liquid
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#1a0515'; // Base Background
        ctx.fillRect(0, 0, width, height);

        blobs.forEach(blob => {
            blob.update();
            blob.draw(ctx, time * config.speed);
        });

        // B. Draw "Vectorized" User
        if (segmentationResults) {
            ctx.save();

            // Step 1: Create a Silhouette (The "Mask")
            // Draw the user mask to clear the area or set clip? 
            // We'll draw the solid Dark Purple shape for the user's body first.
            
            // Draw Mask to Temp Canvas to scale it up properly
            // Actually, we can just draw the mask directly to context using 'source-over'
            // But we want to Color it.
            
            // 1. Draw the user shape in DARK PURPLE (Shadow Color)
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(segmentationResults.segmentationMask, 0, 0, width, height);
            
            // Tint the mask to Dark Purple
            ctx.globalCompositeOperation = 'source-in';
            ctx.fillStyle = '#2e003e'; // Dark liquid color
            ctx.fillRect(0, 0, width, height);
            
            // Now we have a solid dark purple silhouette of you.
            
            // Step 2: Add Highlights (The Pink Parts)
            // We need to know where your face is bright.
            // Draw the video to the small temp canvas
            tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // Get raw pixel data
            const frame = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = frame.data;
            
            // Thresholding: Turn bright pixels White, dark pixels Transparent
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                // Simple brightness calculation
                const brightness = (r + g + b) / 3;
                
                if (brightness > 100) { // Highlight Threshold
                    data[i] = 255;     // R
                    data[i+1] = 0;     // G
                    data[i+2] = 255;   // B (Magenta)
                    data[i+3] = 255;   // Alpha
                } else {
                    data[i+3] = 0;     // Transparent
                }
            }
            tempCtx.putImageData(frame, 0, 0);
            
            // Draw the highlights ON TOP of the silhouette
            // But ONLY where the silhouette exists (Masking)
            ctx.globalCompositeOperation = 'source-atop'; // Only draw on existing pixels (the silhouette)
            
            // Draw the thresholded image, scaled up
            // Use imageSmoothing = false for that jagged "Vector" look? 
            // Or true for smooth. Let's go smooth.
            ctx.drawImage(tempCanvas, 0, 0, width, height);
            
            ctx.restore();
        }

        requestAnimationFrame(loop);
    }
    loop();

    // --- 4. STARTUP ---
    startBtn.addEventListener('click', async () => {
        overlay.style.display = 'none';
        
        // Start Cam
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 360, facingMode: "user" }, // Lower res for speed
            audio: false
        });
        videoElement.srcObject = stream;
        await videoElement.play();

        // Start AI
        initAI();
    });

    function initAI() {
        const selfieSegmentation = new SelfieSegmentation({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
        }});

        selfieSegmentation.setOptions({
            modelSelection: 1, // 0 = general (slower, better), 1 = landscape (faster)
            selfieMode: true
        });

        selfieSegmentation.onResults(results => {
            segmentationResults = results;
        });

        // Throttle AI to 30 FPS to prevent crashing
        async function sendToAI() {
            const now = Date.now();
            if (now - lastTime >= 33) { // ~30ms = 30fps
                if (videoElement.readyState >= 2) {
                    await selfieSegmentation.send({image: videoElement});
                }
                lastTime = now;
            }
            requestAnimationFrame(sendToAI);
        }
        sendToAI();
    }

</script>
</body>
</html>
